## 算法的衡量

### 算法依赖的模型
- 我们假定CPU会顺序的执行所有的指令，而内存随机访问的代价是相同的
    - 整数的变量赋值 消耗1个cpu运算单位
    - 字符串的赋值，类似于数组赋值 每个字符消耗1个cpu运算单位
    - 对象的赋值 创建对象的成本+1次索引+1次赋值
    - '+'、'-'、'*'、'/'、'%' 这些cpu提供的指令 可以认为是消耗1个cpu运算单位
    - 更加复杂的需要引用库等的数学操作，除非指令集上提供了响应的操作，否则不能认为是消耗1个cpu运算单位，但通常运算都在常数级别
    - 逻辑运算 消耗1个cpu运算单位

### 前端提高算法性能的意义
- 流畅问题：为了保证动画的流畅进行，每一帧动画我们只有(1000/60)ms=16ms时间来执行其他计算过程。播放动画的同时我们可能还在请求数据、改变DOM结构、响应事件。（从某种意义上来说服务端轻松的多，因为他们的接口程序通常只需要在100ms内完成执行）
- 老旧机型：前端还有大量机型需要适配，这些机型可能性能没有那么好（比如化为荣耀4a，Android 5.1），在这台机器上亲测一个未经优化设计50多张页面的路由算法执行时间为500ms。如果算法设计失误，在一台机器上执行的算法可能会在另一台机器上产生雪崩效果

### 线性时间的算法
- 举例：
```
    function find(arr,value){
        for(let i=0;i<arr.length;i++){
            if(arr[i]===value){
                return value
            }
        }
        return null
    }
```
- 分析：
```
    最坏的情况：
        第2行 i=0执行了1次；i<arr.length执行了N+1次；i++执行了N次 2N+2
        第3行 比较操作执行了N次 N
        第4行 执行0次 0
        第7行 执行1次 1
    最坏情况下，用时 T=2N+2+N+1=3N+3
```

### 大数定理
> 在随机事件的大量重复出现中，往往呈现几乎必然的规律，这个规律就是大数定理。比如：抛硬币，次数多了之后（比如1万次），正面朝上和反面朝上的数量会趋同

### 复杂度的表示方法
|小写|大写|发音|表示|
|:-|:-:|:-:|-:|
|o|O|ou|渐进上界|
|θ|Θ|theta|渐进紧密界|
|ω|Ω|omega|渐进下界|
> 算法通常执行时间是一个区域，算法的执行时间，空间消耗，会随着输入规模的变化而变化，我们用下面的术语来描述着中变化的关系：O 表示渐进上界；Θ 表示渐进紧密界；Ω 表示渐进下界；
![time.jpg](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572243842837&di=ae509fac58f86cce831d5382cf22920b&imgtype=jpg&src=http%3A%2F%2Fimg4.imgtn.bdimg.com%2Fit%2Fu%3D3401546999%2C1738676424%26fm%3D214%26gp%3D0.jpg)

- 复杂度分析举例
- 递归结构的分析方法

### 面试题
- test01:100w数据随机打乱和排序算法
- test02:大型系统的路由匹配算法